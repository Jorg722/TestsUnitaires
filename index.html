<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		
		<meta name="description" content="Présentation sur les tests unitaires avec reveal.js">
		<meta name="author" content="Jimmy RUNDSTADLER">
		<title>Les Tests Unitaires</title>

		<link rel="stylesheet" href="reveal/css/reset.css">
		<link rel="stylesheet" href="reveal/css/reveal.css">
		<link rel="stylesheet" href="reveal/css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="reveal/lib/css/monokai.css">

		<!-- Custom style -->
		<style type="text/css">
			#footer {
				position: absolute;
				bottom: 0%;
				left: 1%;
			}
			#createdBy {
				position: absolute;
				bottom: 0%;
				left: 50%;
				transform: translate(-50%, 0%);
				text-align: center;
			}
			p{
				font-size: smaller;
			}
			ul, li{
				text-align: justify;
			}
		</style>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- Page de garde-->
				<section>
					<h3>Les Tests Unitaires</h3>
					<h1>Parce que tester c'est bien</h1>
				</section>
				<!-- Présentation -->
				<section>
					<h3>Pourquoi tester ?</h3>
					<p>
						Pour commencer, selon vous c'est quoi un test ?
						<small>
							<ul>
								<li class="fragment fade-in-then-semi-out">Est-ce à l'utilisateur de découvrir les bugs ?</li>
								<li class="fragment fade-in-then-semi-out">Etes vous sûr que votre code fonctionne ?</li>
								<li class="fragment fade-in-then-semi-out">Comment prouver qu'il fonctionne ?</li>
								<li class="fragment fade-in-then-semi-out">Etes vous sûr qu'il fonctionnera toujours si vous y retouchez ?</li>
								<li class="fragment fade-in-then-semi-out">Etes vous sûr qu'il fonctionnera si quelqu'un d'autre y touche ?</li>
							</ul>
						</small>
					</p>
				</section>

				<section>
					<h3>Quoi tester ?</h3>
					<p>
						Quels sont les différents niveaux de tests que l'on peut mettre en place ?
						<small>
							<ul>
								<li class="fragment fade-in-then-semi-out">Des tests unitaires</li>
								<li class="fragment fade-in-then-semi-out">Des tests d'intégration (aka de composants aka de contrats)</li>
								<li class="fragment fade-in-then-semi-out">Des tests automatisés (aka fonctionnels)</li>
								<li class="fragment fade-in-then-semi-out">Des tests manuels</li>
							</ul>
						</small>
					</p>
				</section>

				<section>
					<h3>La pyramide des tests</h3>
					<p>
						<small>
							Dans la pyramide ci-dessous, la base est la moins couteuse à mettre en place et a le retour le plus rapide, le sommet est le plus couteux, mais le plus proche de l'expérience utilisateur.
						</small>
					</p>
					<img src="./img/pyramide.png" width="50%"/>
				</section>

				<section>
					<h3>Quand tester ?</h3>
					<p>
						Il y a 2 approches majeures :
						<small>
							<ul>
								<li class="fragment fade-in-then-semi-out">Le Test Last Development (TLD) aussi connu sous le nom de Test-After</li>
								<li class="fragment fade-in-then-semi-out">Le Test Driven Development (TDD)</li>
							</ul>
						</small>
					</p>
				</section>
				<section>
					<h3>Principes du TLD</h3>
					<p>
						Sans surprise, pour le TLD, le but est d'écrire les tests après le développement. C'est l'approche la plus répandue, notamment pour le code ayant beaucoup d'historique (legacy code) et pour lequel aucun ou très peu de tests sont présents.
					</p>
				</section>
				<section>
					<h3>Principes du TDD</h3>
					<p>
						A l'inverse du TLD, l'approche TDD veut que les tests s'écrivent systématiquement avant le développement.<br />
						Voici les "lois" du TDD :
						<small>
							<ul>
								<li class="fragment fade-in-then-semi-out">Vous devez écrire un test qui échoue avant de pouvoir écrire le code de production correspondant.</li>
								<li class="fragment fade-in-then-semi-out">Vous devez écrire une seule assertion à la fois, qui fait échouer le test ou qui échoue à la compilation.</li>
								<li class="fragment fade-in-then-semi-out">Vous devez écrire le minimum de code de production pour que l'assertion du test actuellement en échec soit satisfaite.</li>
							</ul>
						</small>
					</p>
				</section>
				<section>
					<h3>TDD vs TLD</h3>
					TODOOOOOO
				</section>

<!--
				// Quand tester ?
					// Pro / Con
						// Temps requis
						// Courbe d'apprentissage
						// Productivité et cout de maintenance
						// Taille du code
						// Simplicité du code
					// Comment choisir entre les 2
						// Nature du produit
						// Profil et taille de l'équipe
						// Marché
						// Clean code recommande TDD
				// Avec quoi tester ?
					// Intégration dans Eclipse, et librairies !
						// JUnit
						// AssertJ
						// Mockito
						// WireMock
						// Coverage
					// Couverture de code
						// Le piège de la couverture de code
				// Comment tester proprement ? (Partie Test de Clean Code + Au coeur de JUnit)
					// Garder des tests propres
					// une assertion par test
					// un seul concept par test
					// FIRST ?
					// Inversion de dépendance
					// Documentation par les tests
					// Limite des tests (code mort, code moche, fonction avec trop de responsabilité, etc..)
				// JUnit (dont exception et no exception)
					// votre 1er test : fail
					// quelques exemples de tests
					// before, after, beforeclass, afterclass
					// exception
					// no exception
				// AssertJ
					// apport par rapport à JUnit (lecture naturelle)
					// pu de probleme avec les paramètres de assertEquals notamment
					// quelques exemple avec assertThat (attention assertThat existe aussi sur JUnit, JUnit reprenant pas mal de chose d'AssertJ)
					// assertThatThrowBy (les 2 me vont, JUnit ayant sorti assertThrow)
				// AssertJ ou JUnit ==> les 2 sont compatibles, dont autant prendre le meilleur des 2 !
				// Pour aller plus loin
					// assertTimeout
					// Suite de test
					// Test paramétrés
					// Injection de dépendance (context spring, etc..)
					// Rule
-->
				
				<!-- Remerciements / Questions -->
				<section>
					<h3>Merci de votre attention</h3>
					<p>Des questions ?</p>
				</section>
			</div>
			<div id="footer">
				<small>
					<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
				</small>
			</div>
			<div id="createdBy">
				<small><small>Créée par Jimmy RUNDSTADLER<br />Sources disponibles sur <a href="https://github.com/Jorg722/">github.com/Jorg722</a></small></small>
			</div>
		</div>

		<script src="reveal/js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({

				// Custom config
				transition: 'convex',
				controlsTutorial: true,
				mouseWheel: true,
				hideCursorTime: 2000,
				pdfSeparateFragments: false,

				dependencies: [
					{ src: 'reveal/plugin/markdown/marked.js' },
					{ src: 'reveal/plugin/markdown/markdown.js' },
					{ src: 'reveal/plugin/notes/notes.js', async: true },
					{ src: 'reveal/plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
